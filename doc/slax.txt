#
# $Id: slax.txt,v 1.6 2006/11/03 15:43:05 phil Exp $
#
# Copyright (c) 2006-2008, Juniper Networks, Inc.
# All rights reserved.
# See ./Copyright for the status of this software
#


         SLAX -- Stylesheet Language, Alternative syntaX
                  Phil Shafer <phil@juniper.net>
                      Raleigh, NC

* Abstract

XSLT is a powerful language, but uses an XML-based syntax that is
painful to read and write.  SLAX is an alternative syntax for the XSLT
language, modeled after PERL and C which promotes the basic concepts
of XSLT into first class language constructs.

* SLAX -- An Alternative Syntax for XSLT

XSLT is a commonly used transformation language for XML.  It is a
declarative language that uses XPath expressions to
inspect an XML input document and can generate XML output based on
that input hierarchy.  It's a simple but powerful tool for handling
XML, but the syntax is problematic for developers.

XSLT uses an XML-based syntax, and while XML is great for
machine-to-machine communication, it is inconvenient for humans to
write, especially when writing programs.  The occasional benefits of
having an XSLT stylesheet be an XML document are outweighed by the
readability issues of dealing with the syntax.

SLAX has a simple syntax which follows the style of C and Perl.
Programming constructs and XPath expressions are moved from XML
elements and attributes to first class language constructs.  XML angle
brackets and quotes is replaced by parentheses and curly braces
which are familiar delimiters for programmers.

SLAX allows you to:

- Use if/then/else instead of <xsl:choose> and <xsl:if> elements
- Put test expressions in parentheses
- Use "==" to test equality (to avoid building dangerous habits)
- Use curly braces to show containment instead of closing tags
- Perform concatenation using the "_" operator (lifted from perl6)
- Write text strings using simple quotes instead of the <xsl:text> element
- Simplify invoking named templates with a syntax resembling a
  function call
- Simplify defining named template with a syntax resembling a
  function definition
- Simplify namespace declarations
- Reduce the clutter in scripts, allowing the important parts to be
  more obvious to the reader
- Write more readable scripts

The benefits of SLAX are particularly strong for new developers, since
it puts familiar constructs in familiar syntax, allowing them to
concentrate in the new topics introduced by XSLT.

* Peeking under the hood

SLAX is purely syntactic sugar.  The underlaying constructs are
completely native to XSLT.  Nothing is added to the XSLT engine.  The
SLAX parser parses an input document and builds an XML tree identical
to one produced when the XML parser reads an XSLT document.

SLAX can be viewed as a pre-processor for XSLT, turning SLAX
constructs (like if/then/else) into the equivalent XSLT constructs
(like <xsl:choose> and <xsl:if>) before the real XSLT transformation
engine gets invoked.

The current distribution for libslax is built on libxslt.  SLAX uses
the xsltSetLoaderFunc() in libxslt to tell libxslt to use a different
function when loading script documents.  When xsltParseStylesheetDoc()
loads a script, it then calls the SLAX loader code, which reads the
script, constructs an XML document (xmlDoc) which mimics the document
the normal XML parser would have created for a functionally equivalent
script.  After this document is returned to the existing libxslt code,
normal XSLT processing continues, unaffected by the fact that the
script was written in SLAX.

The "build-as-if" nature of SLAX makes is trivial to write a
SLAX-to-XSLT convertor, which reads in SLAX and emit XSLT.  In
addition, an XSLT-to-SLAX convertor is also available, which
emits an XSLT document in SLAX format.  These make a great learning
aid, as well as allowing conversion of SLAX scripts to XSLT for
environments where libxslt is not available.


* Composite Technologies

SLAX builds on three existing technologies, XML, XPath, and XSLT.

XML is a set of encoding rules that allow simplified parsing of
documents, which gives a simple way to represent hierarchical data
sets in text.  XML parsers can be used to encode any type of content,
and their reuse has breed a set of high-quality implementations that
can be easily incorporated into any software project.  Having a single
encoding helps removing parsing errors, increase code reuse, simplify
developer interaction, reduce development costs, and reduce errors.

XPath is an expression language that allows the specification of sets
of nodes within an XML document.  The language is simultaneously
powerfully expressive in terms of the nodes that can be selected, but
also simple and readable.  It follows the path of making simple things
simple, while making hard things possible.

XSLT is a transformation language that turns XML input document into
an XML output document.  The basic model is that an XSLT engine (or
"processor") reads a script (or stylesheet) and an XML document.  The
XSLT engine uses the instructions in the script to process the XML
document by traversing the document's hierarchy.  The script indicates
what portion of the tree should be traversed, how it should be
inspected, and what XML should be generated at each point.

We'll examine each of these technologies in more detail in the
following sections.

** XML Concepts

XML is a set of encoding rules that allow simplified parsing of
documents, which gives a simple way to represent hierarchical data
sets in text.  There are six basic constructs in XML:

= Open tags: <foo>
    Starts a level of hierarchy.  An open tag and it's matching close
    tag constitute an XML element.  An element can contain additional
    elements, data, or both.

= Close tags: </foo>
    Ends a level of hierarchy.  There must be a close tag for 
    every open tag.

= Empty tags: <foo/>
    Equivalent to <foo></foo>.  Functions as a shorthand.

= Text: <tag>data</tag>
    Any additional text is data.

= Attributes: <tag attribute="value"/>
    Attributes are used to encode name=value pairs inside the open or
    empty tag.  A specific attribute can appear only once per tag.

= Namespaces: <prefix:tag xmlns:prefix="URI"/>
    Defines the scope of a tag, as indicated by the prefix.  This
    allows the same tag used in different namespaces to be unique.  The
    URI is not dereferenced, but provides a unique name for the
    namespace.  The "xmlns:" attribute maps the prefix to the given
    URI.

In addition, comments can be added in XML using the delimiters "<!--"
and "-->".  For example:

    <!-- This is a comment -->

From these simple concepts, hierarchical documents are constructed,
such as the following JUNOS configuration file:

    <configuration xmlns:junos="http://xml.juniper.net/junos/7.1I0/junos">
      <system>
        <host-name>my-router</host-name> 
        <domain-name>example.net</domain-name> 
        <time-zone>America/New_York</time-zone>
        <name-server>
          <name>10.4.1.40</name>
        </name-server>
        <accounting inactive="inactive">
          <events>login</events>
          <events>change-log</events>
          <events>interactive-commands</events>
          <destination>
            <tacplus>
              <server>
                <name>10.1.1.1</name>
              </server>
              <server>
                <name>10.2.2.2</name>
              </server> 
            </tacplus>
          </destination> 
        </accounting>
        <syslog>
          <archive>
            <size>64k</size>
            <files>5</files>
            <world-readable/>
          </archive>
          <host>
            <name>lhs</name>
            <contents>
              <name>any</name>
              <alert/>
            </contents>
            <explicit-priority/>
          </host>
        </syslog>
      </system>
      <routing-options>
        <static>
          <route>
            <name>0.0.0.0/0</name>
            <next-hop>10.10.1.1</next-hop>
            <retain/>
          </route>
        </static>
        <autonomous-system inactive="inactive">
          <as-number>42</as-number>
          <loops>9</loops>
        </autonomous-system>
      </routing-options>
    </configuration>

@see http://www.w3c.org/TR/REC-xml. 

** XPath Concepts

The XPath expression language allows selection of arbitrary nodes from
with an XML document using three key concepts.

*** Paths

An XPath expression can include a path of XML elements names, which
select child nodes based on their ancestors' names.  Each member of
the path must match an existing node, and only nodes that match all
path members will be included in the results.  The members of the path
are separated by the slash character ('/').

For example, the following expression selects all <paragraph> elements
that are parented by a <section> element, which in turn must be
parented by a <chapter> element, which must be parented by a <doc>
element. 

    doc/chapter/section/paragraph

*** Axis

XSLT views nodes as being arranged in certain "axes".  The "ancestor"
axis points from a node up through it's series of parent nodes.  The
"child" axis points through the list of an element node's direct child
nodes.  The "attribute" axis points through the list of an element
node's set of attributes.  The "following-sibling" axis points through
the nodes which follow a node but are under the same parent, while the
"proceeding-sibling" axis points through the nodes that appear before
a node and are under the parent.  The "descendant" axis contains all
the descendents of a node.  There are numerous other axes which are
not detailed here.

When referring to an axis, use the axis name followed by two colons
followed by the element name (which may include an optional prefix and
it's trailing colon).

There are two axis aliases that make a convenient shorthand when
writing expressions.  The "@" alias refers to the attribute axis,
allowing either "attribute::number" or "@number" to refer to the
"number" attribute.  The "//" alias refers to the "descendant-or-self"
axis, so "doc//paragraph" will find all <paragraph> elements that have
a <doc> element as an ancestor.

@see

*** Predicates

A predicate is a boolean test must be satisfied for a node to be
selected.  Each path member of the XPath expression can have zero or
more predicates specified, and the expression will only select nodes
for which all the predicates are true.

** XSLT Concepts


* Statements

This section lists the SLAX statements, with brief examples followed
by their XSLT equivalents.  The utility of SLAX will hopefully be
appearent, as will the simple transformation that SLAX parsing code is
performing.

** Expressions @expressions@

SLAX makes extensive use of the XPath expression language.
Expressions are used to select nodes, specify conditions, and to
generate output content.  Expressions contain five constructs:

- Paths to elements
-- Select nodes based on node names
--- Example: chapter
-- Selects child nodes based on parent node names
--- Example: doc/chapter/section/paragraph
-- Selects child nodes under at any depth
--- Example: doc//paragraph
-- Selects parent nodes relative to the current node
--- Example: ../../chapter
-- Selects attributes using "@" followed by attribute name
--- Example: ../../chapter/@number

- Predicate tests
-- Selects nodes for which the expression in the square brackets
evaluates to "true" (with boolean() type conversion)
--- Example chapter[@number == 1]
-- Can be applied to any path member
--- Example: chapter[@number == 1]/section[@number == 2]
-- Use a number to select the <n>th node from a node set
--- Example: chapter[1]
-- Multiple predicate tests can be specified (ANDed together)
--- Example: chapter[@number > 15][section/@number > 15]

- References to variables or parameters
-- Variable and parameter names start with "$"
--- Example: $this
-- Variables can hold expressions, node sets, etc
--- Example: $this/paragraph
-- 

- Literal strings
-- SLAX accepts single or double quotes
--- Example: "test"
-- Character escaping is allowed
--- Example: '\tthat\'s good\n\tnow what?\n'

- Calls to functions
-- Function calls can be used in expressions or predicate tests
--- Example: chapter[count(section) > 15]
-- Allows calls to pre-defined or user-defined functions
--- Example: chapter[substring-before(title, "ne") == "O"]

SLAX follows XPath syntax, with the following exceptions:

(a) "&&" may be used in place of the "and" operator
(b) "||" may be used in place of the "or" operator
(c) "==" may be used in place of the "=" operator
(d) "_" is the concatenation operator ("a" _ "b" === concat("a", "b"))

The first three exceptions are meant to prevent programmers from
learning habits in SLAX that will negatively affect their ability to
program in other languages.  The last exception is for convenience.

** Creating the Result Tree

SLAX (and XSLT) is a "declarative" language, meaning that a SLAX
script will describe the output that should be generated, not give
imperative instructions about how to generate that output.  This is
quite different than traditional procedural programming, in both
content and style.

As a SLAX script executes, it uses the description contained in rules
and templates to generate a "result tree", which is a hierarchy of XML
output nodes.  Some logic statements and conditional processing
statements are intermixed with the output description to allow
flexibility in the output generated.

We'll start by examining how SLAX generated these output nodes.

**** Namespaces

Namespaces map URI strings to prefixes that are used to indicate the
administrative domain of specific XML elements.  The syntax and
semantic constraints for the element <size> will be distinct depending
on the namespace under which it is defined.

The URI is a string that uniquely identifies the namespace.  Here are
some examples:
|-------|
| Example namespaces |
|-------|
| http://xml.juniper.net/junos |
| http://www.example.com/example-one |
| http://www.w3.org/1999/XSL/Format |
| http://www.w3.org/Graphics/SVG/SVG-19990812.dtd |
|-------|

The prefix is a string string pre-pended to the local element name with a
colon.

|---|----|
| Example Prefix | Example Element Usage |
|---|----|
| junos | <junos:name/> |
| example | <example:name/> |
| fo | <fo:name/> |
| svg | <svg:name/> |
|---|----|

**** The "ns" Statement @ns@

The "ns" statement defines a mapping from a prefix to a URI namespace
identifier.  Namespaces must be defined prior to their use.

By default, elements are in the "null" namespace, but the "ns"
statement can be used to change the namespace for unprefixed elements.

The syntax of the "ns" statement is:

    ns [<prefix> <options> = ] <uri>;

If a prefix is the value prefixed to element names to indicate their
namespace should be that of the given URI.   If no prefix is given,
the given URI will be applied to all elements that do not include a
prefix.  The values and meanings of <options> are detailed below.

    ns junos =  "http://xml.juniper.net/junos";
    ns example = "http://www.example.com/example-one";
    ns fo = "http://www.w3.org/1999/XSL/Format";
    ns svg = "http://www.w3.org/Graphics/SVG/SVG-19990812.dtd";

In this example, a default namespace is defined, as well as a
namespace mapped to the "test" prefix:

    ns "http://example.com/main";
    ns test = "http://example.com/test";

The XML equivalent is:

    <some-element xmlns="http://example.com/main"
            xmlns:test="http://example.com/test"/>

@see http://www.w3.org/TR/xml#namespaces

***** Reserved Prefixes

All prefixes beginning with "xml" are reserved for XML.  In addition,
all prefixes beginning with "slax" are reserved for SLAX.

***** The "extension" Statement @extension@

The "extension" statement instructs the processing engine that
extenstion namespaces, which will cause elements in that namespace to
be given special handling by the engine.

@see http://www.w3.org/TR/xslt#extension-element

***** The "exclude" Statement @exclude@

The "exclude" statement prevents the namespace from appearing in the
result tree.

@see http://www.w3.org/TR/xslt#literal-result-element

*** Elements

Elements are the primary encoding mechanism of XML, and can be
combined and arranged to encoding complex hierarchical constructs.

The XML encoding uses three tags: the start tag, the end tag, and the
empty tag.  The start tag consists of the less than character ('<'),
the element name, a set of optional attributes (discussed later), and
the greater than character ('>').  This is followed by the contents of
the XML element, which may include additional elements.  The end tag
consists of the less than character ('<'), the slash character ('/'),
the element name, and the greater than character ('>').  If an element
has no content, an empty tag can be used in place of an open and close
tags.  The empty tag consists of the less than character ('<'), the
element name, a set of optional attributes (discussed later), the
slash character ('/'), and the greater than character ('>').

    <doc>
        <chapter number="1" name="Introduction">
            <section>
                <paragraph>
                     This is a brief introduction.
                </paragraph>
            </section>
       </chapter>
    </doc>

**** XML Elements



**** The "element" Statement @element@

*** Attributes

**** XML Attributes

**** The "attribute" Statement @attribute@

*** Attribute Sets

**** The "attribute-set" Statement @attribute-set@

**** The "use-attribute-sets" Statement @use-attribute-sets@

*** Expressions

**** expr

**** uexpr

*** Processing Instructions

**** The "processing-instruction" Statement @processing-instruction@

*** Comments

**** The "comment" Statement @comment@

*** Copying Content

**** The "copy-of" Statement @copy-of@

**** The "copy-node" Statement @copy-node@

*** Formatting

**** The "number" Statement @number@

** Templates @templates@

A SLAX script consists of a set of templates.  There are two types of
templates, match templates and named templates.  This section
discusses each of these types.

*** Named Templates

In addition to the template processing, templates can be given
explicit names and called directly, allowing a programming style that
follows more traditional procedural languages.  Named templates are
called like function, returning their XML output nodes to the caller,
where they can be merged into the caller's XML output tree.

**** The "template" Statement @template@

Named templates are defined using their name and parameters and
invoked using the "call" statement.  The template definition consists
of the "template" keyword, the template name, a set of parameters, and
a braces-delineated block of code.  Parameter declarations can be
either inline, with the parameter name and optionally an equals sign
("=") and a value expression.  Additional parameters can be declared
inside the block using the "param" statement.

The template is invoked using the "call" statement, which consists of
the "call" keyword followed by a set of parameter bindings.  These
binding are a comma-separated list of parameter names, optionally
followed by an equal sign and a value expression.  If the value is not
given, the current value of that variable or parameter is passed,
giving a simple shorthand for passing parameters if common names are
used.  Additional template parameters can be supplied inside the block
using the "with" statement.

**** The "call" Statement @call@

Named templates accept parameters by name, rather than by position.
This means the caller needs to indicate the name of the desired parameter


**** The "match" Statement @named-match@

**** Example

    match configuration {
        var $name-servers = name-servers/name;
        call temp:ting();
        call temp:ting($name-servers, $size = count($name-servers));
        call temp:ting() {
            with $name-servers;
            with $size = count($name-servers);
        }
    }

    template temp:ting($name-servers, $size = 0) {
        <output> "template called with size " _ $size;
    }

The XSLT equivalent:

    <xsl:template match="configuration">
      <xsl:variable name="name-servers" select="name-servers/name"/>
      <xsl:call-template name="temp:ting"/>
      <xsl:call-template name="temp:ting">
        <xsl:with-param name="name-servers" select="$name-servers"/>
        <xsl:with-param name="size" select="count($name-servers)"/>
      </xsl:call-template>
      <xsl:call-template name="temp:ting">
        <xsl:with-param name="name-servers" select="$name-servers"/>
        <xsl:with-param name="size" select="count($name-servers)"/>
      </xsl:call-template>
    </xsl:template>

    <xsl:template name="temp:ting">
      <xsl:param name="name-servers"/>
      <xsl:param name="size" select="0"/>
      <output>
        <xsl:value-of
             select="concat('template called with size ', $size)"/>
      </output>
    </xsl:template>


*** Match Templates @match-templates@

The processing model for SLAX is identical to that of XSLT.  A set of
XML input nodes are processed to generate a set of XML output nodes.
This processing begins at the top of the XML input document and
proceeds recursively through the entire document, using rules defined
in the SLAX script, rules imported from other scripts, and a set of
default rules defined by the XSLT specification.

Each rule defines the matching criteria that controls when the rule is
applied, followed by a template for the creation of the XML output
nodes.  The processing engine inspects each node, finds the
appropriate rule that matches that node, executes the template
associated with the rules, builds the XML output nodes, and merges
those nodes with the XML output nodes from other rules to build the
XML output nodes.

**** The "match" Statement @match@

The "match" statement defines a match template, with its matching
criteria and its template.  The keyword "match" is followed by an
XPath expression that selects the nodes on which this template should
be executed.  This is followed by a set of curly braces containing the
template.

    match _expression_ {
        _template_
    }

The template consists of SLAX code, whose statements are defined later
in this document.

**** The "apply-templates" Statement @apply-templates@

The "apply-templates" statement instructs the processing engine to
apply the set of templates given in the script to a set of nodes.  The
statement takes as its argument an XPath expression that selects a set
of nodes to use.  If no expression is given, the current node is used.

The set of XML input nodes is processed according to the set of
templates, and the XML output nodes are given to the context in which
the apply-templates statement was issued.

**** The "mode" Statement @mode@

The "mode" statement allows the apply-template to choice a distinct
set of rules to use during processing.  The argument to the "mode"
statement is a text string that identifies the mode for both the
template and the template processing.  Templates processing will only
select templates that match the current mode value.  If no mode
statement is given with an "apply-templates" invocation, then the
current mode remains in effect.

In this example, template processing is invoked twice, first for mode
"content" and then for mode "index".

    match doc {
        apply-templates {
            mode "content";
        }
        apply-template {
            mode "index";
        }
    }

    match paragraph {
        mode "content";
        ... template ...
    }

    match paragraph {
        mode "index";
        ... template ...
    }

@see http://www.w3.org/TR/xslt#modes

**** The "priority" Statement @priority@

The "priority" statement sets the priority of the template, which is
used as part of the conflict resolution when more that one template
matches a source node.  The highest priority rule is chosen.  The
argument to the "priority" statement is a real number (positive or
negative).

In this example, the template is given a high priority:

    match paragraph {
        priority 100;
        ...
    }

@see http://www.w3.org/TR/xslt#conflict

**** The "param" Statement

Template can accept parameters from their 

**** The "with-param" Statement


** Programming Constructs

*** Variables

**** The "var" Statement @var@

*** Parameters

**** The "param" Statement @param@

**** The "with" Statement @with@

*** Result Tree Fragments

**** The ":=" Operator @colon-equals@

*** Control

**** The "for-each" Statement @for-each@

**** The "sort" Statement @sort@

**** The "if" and "else" Statements @if-else@

SLAX supports an "if" statement that uses a C-like syntax.  The
expressions that appear in parentheses are extended form of XPath
expressions, which support the double equal sign ("==") in place of
XPath's single equal sign ("=").  This allows C programmers to avoid
slipping into dangerous habits.

    if (this && that || the/other[one]) {
        /* SLAX has a simple "if" statement */
    } else if (yet[more == "fun"]) {
        /* ... and it has "else if" */
    } else {
        /* ... and "else" */
    }

Depending on the presence of the "else" clause, an "if" statement can
be transformed into either an <xsl:if> element or an <xsl:choose>
element.

    if (starts-with(name, "fe-")) {
        if (mtu < 1500) {
           /* Deal with fast ethernet interfaces with low MTUs */
        }
    } else {
        if (mtu > 8096) {
           /* Deal with non-fe interfaces with high MTUs */
        }
    }

The XSLT equivalent:

    <xsl:choose>
      <xsl:when select="starts-with(name, 'fe-')">
        <xsl:if test="mtu &lt; 1500">
          <!-- Deal with fast ethernet interfaces with low MTUs -->
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="mtu &gt; 8096">
          <!-- Deal with non-fe interfaces with high MTUs -->
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>

*** Functions

**** The "function" Statement @function@

**** The "result" Statement @result@

** Other Functionality

*** Combining Scripts

**** The "import" Statement @import@

**** The "include" Statement @include@

*** Additional XPath Functions

**** The "key" Statement @key@

**** The "decimal-format" Statement @decimal-format@

*** Messages

**** The "message" Statement @message@

**** The "terminate" Statement @terminate@

**** The "trace" Statement @trace@

*** Output

**** The "output-method" Statement @output-method@

**** The "strip-space" Statement @strip-space@

**** The "preserve-space" Statement @preserve-space@

*** Versioning

**** The "version" Statement @version@

* Old Stuff

** if/then/else

** Elements

SLAX elements are written with in a C-like syntax, with only the open
tag.  The contents of the tag appear immediately following the open
tag.  These contents can either be a simple expression, or a more
complex expression placed inside braces:

  <top> {
      <one>;
      <two> {
          <three>;
          <four>;
          <five> {
              <six>;
          }
      }
  }

This is equivalent to:

  <top>
    <one/>
    <two>
      <three/>
      <four/>
      <five>
        <six/>
      </five>
    </two>
  </top>

Programmers are used to using braces, indentations, and editor support
to delineate blocks of data.  Using these nesting techniques and
removing the close tag reduces the clutter and increases the clarity
of code.

** Expressions

XPath expressions can appear as either the contents of an XML element
or as the contents of a "expr" (expression) statement.  In either
case, the value is translated in an <xsl:text> or <xsl:value-of>
element.

Strings are encoded using quotes (single or double) in a way that will
feel natural to C programmers.  The concatenation operator is
underscore ("_"), which is the new concatenation operator for Perl 6.
(The use of "+" or "." would have created ambiguities in the SLAX
language.)

    <top> {
        <one> "test";
        <two> "The answer is " _ results/answer _ ".";
        <three> results/count _ " attempts made by " _ results/user;
        <four> {
            expr results/count _ " attempts made by " _ results/user;
        }
        <five> {
            expr results/count;
            expr " attempts made by ";
            expr results/user;
        }
        <six> results/message;
    }

The equivalent XSLT:

    <top>
      <one><xsl:text>test</xsl:text></one>
      <two><xsl:value-of select='concat("The answer is ", 
                                    results/answer, ".")'/></two>
      <three><xsl:value-of select='concat(results/count,
                   " attempts made by ", , results/user)'/></three>
      <four><xsl:value-of select='concat(results/count,
                   " attempts made by ", , results/user)'/></four>
      <five>
        <xsl:value-of select="results/count"/>
        <xsl:text> attempts made by </xsl:text>
        <xsl:value-of select="results/user"/>
      </five>
      <six><xsl:value-of select='results/message'/></six>
    </top>

In this example, the contents of the <three> and <four> element are
identical, and the <five> element's contents are nearly identical,
differing only in the use of the XPath concat() function.

** Variables and Parameters

Variable and parameter syntax uses the "var" and "param" statements to
declare variables and parameters, respectively.  SLAX declarations
differ from XSLT in that the variable name contains the dollar sign
even in the declaration, which is unlike the "name" attribute of
<xsl:variable> and <xsl:parameter>.  This was done to enhance the
consistency of the language.

    param $fido;
    var $bone;

The XSLT equivalent:

    <xsl:parameter name="fido"/>
    <xsl:variable name="bone"/>

An initial value can be given by following the variable name with an
equals sign and an expression.

    param $dot = .;
    var $location = $dot/@location;
    var $message = "We are in " _ $location _ " now.";

The XSLT equivalent:

    <xsl:parameter name="dot" select="."/>
    <xsl:variable name="location" select="$dot/location"/>
    <xsl:variable name="message" select="concat('We are in ',
                                           $location, ' now.')"/>

Again, these are the same constucts as XSLT, but packaged in a more
readable, maintainable syntax.

** Attributes

Attributes on elements follow the style of XML, with the attribute
name, an equals sign, and the value of the attribute.

    <element attr1="one" attr2="two">;

Where XSLT allow attribute value templates using curly braces, SLAX
uses the normal expression syntax.  Attribute values can be any XPath
expression, including quoted strings, parameters, variables, and
numbers, as well as the SLAX concatenation operator ("_").

    <location state=$location/state
              zip=$location/zip5 _ "-" _ $location/zip4>;

The XSLT equivalent:

    <location state="{$location/state}"
              zip="{concat($location/zip5, "-", $location/zip4}"/>

Note that curly braces placed inside quote strings are not
interpreted as attribute value templates, but as real braces
and are escaped when translated into XSLT.

    <avt sign="{here}">;

The XSLT equivalent:
   
    <avt sign="{{here}}"/>

** The "match" statement

Basic match templates are specified using the "match" statement,
followed by an expression specifying when the template should be
allowed.  This is followed by a block of statements enclosed in a set
of braces.

    match configuration {
        <error> {
            <message> "System is named " _ system/host-name;
        }
    }

** Applying Templates

Match templates are applied using the "apply-templates" statement.
The statement accepts an optional XPath expression, which is
equivalent to the "select" in an <xsl:apply-templates> element.

    match configuration {
        apply-template system/host-name;
    }

    match host-name {
        <hello> .;
    }

The XSLT equivalent:

    <xsl:template match="configuration">
      <xsl:apply-templates select="system/host-name"/>
    </xsl:template>

    <xsl:template match="host-name">
      <hello>
        <xsl:value-of select="."/>
      </hello>
    </xsl:template>

** Template Parameters

Parameters may be passed to match templates using the "with"
statement.  The "with" statement consists of the keyword "with" and
the name of the parameter, optionally followed by an equals sign ("=")
and a value expression.  If no value is given, the current value of
that variable or parameter is passed, giving a simple shorthand for
passing parameters if common names are used.

    match configuration {
        var $domain = domain-name;
        apply-template system/host-name {
            with $message = "Invalid host-name";
            with $domain;
        }
    }

    match host-name {
        param $message = "Error";
        param $domain;
        <hello> $message _ ":: " _ . _ " (" _ $domain _ ")";
    }

The XSLT equivalent:

    <xsl:template match="configuration">
      <xsl:apply-templates select="system/host-name">
        <xsl:with-param name="message" select="'Invalid host-name'"/>
        <xsl:with-param name="domain" select="$domain"/>
      </xsl:apply-templates>
    </xsl:template>

    <xsl:template match="host-name">
      <xsl:param name="message" select="'Error'"/>
      <xsl:param name="domain"/>
      <hello>
        <xsl:value-of select="concat($message, ':: ', ., 
                                    ' (', $domain, ')')"/>
      </hello>
    </xsl:template>

** The "mode" Statement

The "mode" attribute of the <xsl:template> element is available
using the "mode" statement.  This statement can appear inside a
"match" statement and inside an "apply-templates" statement.

    match * {
        mode "one";
        <one> .;
    }

    match * {
        mode "two";
        <two> string-length(.);
    }

    match / {
        apply-templates version {
            mode "one";
        }
        apply-templates version {
            mode "two";
        }
    }

The XSLT equivalent:

    <xsl:template match="*" mode="one">
      <one>
        <xsl:value-of select="."/>
      </one>
    </xsl:template>

    <xsl:template match="*" mode="two">
      <two>
        <xsl:value-of select="string-length(.)"/>
      </two>
    </xsl:template>

    <xsl:template match="/">
      <xsl:apply-template select="version" mode="one"/>
      <xsl:apply-template select="version" mode="two"/>
    </xsl:template>


** The "priority" Statement

The "priority" statement mimics the "priority" attribute of the
<xsl:template> element.  It may appear inside a "match" statement.

    match * {
        priority 10;
        <output> .;
    }

The XSLT equivalent:


    <xsl:template match="*" priority="10">
      <output>
        <xsl:value-of select="."/>
      </output>
    </xsl:template>

** Named Templates

** The "for-each" Statement

The "for-each" statement mimics functionality of the <xsl:for-each>
element.  The statement consists of the "for-each" keyword, the
parentheses-delimited select expression, and a block.

    for-each ($inventory/chassis/chassis-module
              /chassis-sub-module[part-number == '750-000610']) {
        <message> "Down rev PIC in " _ ../name _ ", "
                     _ name _ ": " _ description;
    }

The XSLT equivalent:


    <xsl:for-each select="$inventory/chassis/chassis-module
              /chassis-sub-module[part-number == '750-000610']">
        <message>
            <xsl:value-of select="concat('Down rev PIC in ', ../name,
                                  ', ', name, ': ', description)"/>
        </message>
    </xsl:for-each>

** "version"

    version 1.1;

All SLAX stylesheets must begin with a "version" statement, which
gives the version number for the SLAX language.  This is currently
fixed at "1.1" and will increase as the language evolves.  Version
1.1 is completely backward compatible with version 1.0, but adds
additional functionality that may cause issues for implementations
of SLAX 1.0.

SLAX version 1.1 implies XML version 1.0 and XSLT version 1.1.

In addition, the "xsl" namespace is implicitly defined (as
'xmlns:xsl="http://www.w3.org/1999/XSL/Transform"').

** The "ns" Statement

Namespace definitions are supplied using the "ns" statement.  This
consists of either the "ns" keyword, a prefix string, an equal sign
and a namespace URI or the "ns" keyword and a namespace URI.  The
second form defines the default namespace.

    ns junos = "http://www.juniper.net/junos/";

The "ns" statement may appear either following the "version" statement
at the beginning of the stylesheet or at the beginning of any block.

    ns a = "http://example.com/1";
    ns "http://example.com/global";
    ns b = "http://example.com/2";

    match / {
        ns c = "http://example.com/3";
        <top> {
            ns a = "http://example.com/4";
            apply-templates commit-script-input/configuration;
        }
    }

When appearing at the beginning of the stylesheet, the ns statement
may include either the "exclude" or "extension" keywords.  These
keywords instruct the parser to add the namespace prefix to the
"exclude-result-prefixes" or "extension-element-prefixes" attribute.

    ns exclude foo = "http://example.com/foo";
    ns extension jcs = "http://xml.juniper.net/jcs";

The XSLT equivalent:

    <xsl:stylesheet xmlns:foo="http://example.com/foo"
                    xmlns:jcs="http://xml.juniper.net/jcs"
                    exclude-result-prefixes="foo"
                    extension-element-prefixes="jcs">
        <!-- ... -->
    </xsl:stylesheet>

** The "copy-of" Statement

The "copy-of" statement mimics the functionality of the <xsl:copy-of>
element.

    copy-of configuration/protocols/bgp;

The XSLT equivalent:

   <xsl:copy-of select="configuration/protocols/bgp"/>

** The "apply-imports" Statement

The "apply-imports" statement mimics the <xsl:apply-imports> element,
allowing the script to invoke any imported templates.

    apply-imports;

The XSLT equivalent:

   <xsl:apply-imports/>

** The "include" and "import" Statements

The "include" and "import" statements mimic the <xsl:include> and
<xsl:import> elements.

    include "foo.slax";
    import "goo.xsl";

The XSLT equivalent:

    <xsl:include href="foo.slax"/>
    <xsl:import href="goo.xsl"/>

Import and include documents do _not_ need to be in written in SLAX.
SLAX can import and include normal XSLT documents.

** The "comment" Statement

The "comment" statement mimics the <xsl:comment> element, allowing XML
comments to be generated.

    comment "Added by user " _ $user _ " on " _ $date;

The XSLT equivalent:

    <xsl:comment>
      <xsl:value-of 
           select='concat("Added by user ", $user, " on ", $date)'/>
    </xsl:comment>

** The "preserve-space" Statement

The "preserve-space" statement mimics the <xsl:preserve-space>
element, instructing the XSLT processor that certain elements
should have internal whitespace retained.

    preserve-space foo goo moo;

The XSLT equivalent:

    <xsl:preserve-space elements="foo goo moo"/>

** The "strip-space" Statement

The "strip-space" statement mimics the <xsl:strip-space>
element, instructing the XSLT processor that certain elements
should have internal whitespace removed.

    strip-space foo goo moo;

The XSLT equivalent:

    <xsl:strip-space elements="foo goo moo"/>

** Comments

Comments in SLAX are entered in the traditional C style, beginning the
"/*" and ending with "*/".  These comments are preserved in the
in-memory XML tree representation of the SLAX script.  This allows
comments to be preserved if the tree is emitted using the normal
XML output renderer.

    /*
     * This is a comment.
     */

The XSLT equivalent:

    <!-- /*
     * This is a comment
     */ -->

** Other XSLT Elements

A number of rarely used XSLT elements are not directly translated into
SLAX statements.  Many of these elments are either rarely used or
fairly complex, requiring the developer to refer to the XSLT spec (or
the Kay book) for the syntax.  Adding a new SLAX syntax would make the
developer's life harder, rather than helping them.  In some cases, the
saving from making a SLAX version of the XSLT element is simply not
sufficient to warrant a new syntax.

These elements can be encoded directly as normal SLAX elements in the
XSLT namespace:

    <xsl:output method="xml" indent="yes" media-type="image/svg">;

    match * {
        for-each (configuration/interfaces/unit) {
            <xsl:sort some-obnoxious-option="some-obnoxious-value">;
        }
    }

* Example Stylesheets

This section contains a few examples, converted from the libxslt test/
directory.  The XSLT form can be found in the libxslt source code.
They were converted using the slax writer.

** general/itemschoose.xsl

    version 1.0;
 
    ns fo = "http://www.w3.org/1999/XSL/Format";
 
    strip-space itemlist;
    match doc {
        <doc> {
            apply-templates;
        }
    }
    match orderedlist/listitem {
        <fo:list-item indent-start="2pi"> {
            <fo:list-item-label> {
                var $level = count(ancestor::orderedlist) mod 3;
     
                if ($level=1) {
                    <number format="i">;
     
                } else if ($level=2) {
                    <number format="a">;
     
                } else {
                    <number format="1">;
                }
                expr ". ";
            }
            <fo:list-item-body> {
                apply-templates;
            }
        }
    }

** REC2/svg.xsl

    version 1.0;
 
    ns "http://www.w3.org/Graphics/SVG/SVG-19990812.dtd";
 
    <xsl:output method="xml" indent="yes" media-type="image/svg">;
    match / {
        <svg width="3in" height="3in"> {
            <g style="stroke: #000000"> {
                /* draw the axes */
                <line x1="0" x2="150" y1="150" y2="150">;
                <line x1="0" x2="0" y1="0" y2="150">;
                <text x="0" y="10"> "Revenue";
                <text x="150" y="165"> "Division";
                for-each (sales/division) {
                    /* define some useful variables */
                    /* the bar's x position */
                    var $pos = (position()*40)-30;
                    /* the bar's height */
                    var $height = revenue*10;
                    /* the rectangle */
                    <rect x=$pos y=150 - $height 
                          width="20" height=$height>;
                    /* the text label */
                    <text x=$pos y="165"> @id;
                    /* the bar value */
                    <text x=$pos y=145 - $height> revenue;
                }
            }
        }
    }

** XSLTMark/metric.xsl

    version 1.0;
 
    <xsl:output method="html" encoding="utf-8">;
    match measurement {
        var $m = {
            if (@fromunit == 'km') {
                expr . * 1000;
     
            } else if (@fromunit == 'm') {
                expr .;
     
            } else if (@fromunit == 'cm') {
                expr . * 0.01;
     
            } else if (@fromunit == 'mm') {
                expr . * 0.001;
            }
        }
        <measurement unit=@tounit> {
            if (@tounit == 'mi') {
                expr 0.00062137 * $m;
     
            } else if (@tounit == 'yd') {
                expr 1.09361 * $m;
     
            } else if (@tounit == 'ft') {
                expr 3.2808 * $m;
     
            } else if (@tounit == 'in') {
                expr 39.37 * $m;
            }
        }
    }

* Odd and Annoying Topics

*** Type Promotion for XPath Expressions

XPath expressions use a style of type promotion that coerces values
into the particular type needed for the expression.  For example, if
a predicate refers to a node, then that predicate is true if the node
exists.  The value of the node is not considered, just it's
existence.

For example, the expression "chapter[section]" selects all
chapters that have a section element as a child.

Similarly, if a predicate uses a function that needs a string, the
argument is converted to a string value by concatenating all the text
values of that node and all that node's child elements.

For example, the expression "chapter[starts-with(section, 'A')]" will
inspect all <chapter> elements, convert their <section> elements 


* Status of the Software

The SLAX software contains both a reader and a writer.  The reader
turns a SLAX source file into an XSLT tree (xmlDocPtr) using the
xsltSetLoaderFunc() hook.

The writer turns an XSLT tree (xmlDocPtr) into a file containing
SLAX statements.
