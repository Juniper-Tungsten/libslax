/*
 * Copyright (c) 2016, Juniper Networks, Inc.
 * All rights reserved.
 * This SOFTWARE is licensed under the LICENSE provided in the
 * ../Copyright file. By downloading, installing, copying, or otherwise
 * using the SOFTWARE, you agree to be bound by the terms of that
 * LICENSE.
 *
 * Phil Shafer (phil@) June 2016
 *
 * We compile scripts into a set of rules, behaviors that are
 * triggered based on incoming elements.  These rules exist in their
 * own memory segment (pa_mmap_t) so they can be compiled once and
 * reused as needed.
 *
 * Rules are patterns to match and actions to execute when matched.
 * They are typically generated by compiling a script, but can be
 * generated directly.
 *
 * Rules are built in "states" (think YACC states) where a set of
 * rules
 */

#ifndef LIBSLAX_XI_RULES_H
#define LIBSLAX_XI_RULES_H

typedef uint8_t xi_action_type_t;

/* Values for xi_action_type_t */
#define XIA_NONE	0
#define XIA_DISCARD	1	/* Discard with all due haste */
#define XIA_SAVE	2	/* Save node (at insertion point) */
#define XIA_SAVE_ATSTR	3	/* Save node and attribute string */
#define XIA_SAVE_ATTRIB	4	/* Save node and parsed attributes */
#define XIA_EMIT	5	/* Emit as output */
#define XIA_RETURN	6	/* Force return from xi_parse() */

/* Number to represent each rule */
PA_FIXED_ATOM_TYPE(xi_rule_id_t, xi_rule_id_s, xr_atom, xi_rule_id,
	   xi_rule_id_atom_of, xi_rule_id_is_null, xi_rule_id_null_atom);

/* Number to represent each state */
PA_FIXED_ATOM_TYPE(xi_rstate_id_t, xi_rstate_id_s, xrs_atom, xi_rstate_id,
	   xi_rstate_id_atom_of, xi_rstate_id_is_null, xi_rstate_id_null_atom);

/*
 * A rule defines a behavior for an incoming token.  A token can be
 * copied, saved, or discarded.  Or a function callback can triggered.
 */
typedef struct xi_rule_s {
    xi_rule_id_t xr_next;	/* Next rule for this state */
    uint32_t xr_flags;		/* Flags for this rule */
    pa_bitmap_id_t xr_bitmap;	/* Elements affected by this rule */
    xi_action_type_t xr_action;	/* What to do when the rule matches */
    pa_atom_t xr_use_tag;	/* Different tag to emit */
    xi_rstate_id_t xr_new_state; /* New state (in the rulebook) to enter */
} xi_rule_t;

/* Flags for xr_flags */
#define XRF_MATCH_ALL	(1<<0)	/* Wildcard match */

/*
 * A state represents a set of associated rules
 */
typedef struct xi_rstate_s {
    xi_rule_id_t xrbs_first_rule; /* Number of first rule (in xb_rules) */
    xi_rule_id_t xrbs_default_rule; /* Number of default rule (in xb_rules) */
    uint16_t xrbs_flags;	/* Flags for this state */
} xi_rstate_t;

/* Flags for xrbs_flags */
#define XRBSF_INUSE	(1<<0)	/* State is used/defined */

typedef struct xi_rulebook_info_s {
    xi_rstate_id_t xrsi_initial_state; /* First state in the rule book */
    xi_rstate_id_t xrsi_max_state;     /* Maximum allocated (seen) state */
} xi_rulebook_info_t;

/*
 * A rule set is an optimized set of rules
 */
typedef struct xi_rulebook_s {
    xi_workspace_t *xrb_workspace; /* Our workspace */
    xi_parse_t *xrb_script;	  /* Script we're loading/building */
    xi_rulebook_info_t *xrb_infop; /* Our information the the pa_mmap_t */
    pa_fixed_t *xrb_rules;	  /* List of rules (xi_rule_t) */
    pa_fixed_t *xrb_states;	  /* List of states (xi_rule_state_t) */
    pa_bitmap_t *xrb_bitmaps;	  /* Pool of bitmaps */
} xi_rulebook_t;

xi_rulebook_t *
xi_rulebook_open (const char *name);

xi_rulebook_t *
xi_rulebook_setup (xi_workspace_t *xwp, xi_parse_t *script, const char *name);

void
xi_rulebook_close (xi_rulebook_t *rules);

xi_rule_t *
xi_rulebook_find (xi_parse_t *parsep, xi_rulebook_t *xrbp, xi_rstate_t *statep,
		  pa_atom_t name_atom, const char *pref, const char *name,
		  const char *attribs);

xi_rulebook_t *
xi_rulebook_prep (xi_parse_t *input, const char *name);

void
xi_rulebook_dump (xi_rulebook_t *xrbp);

PA_FIXED_FUNCTIONS(xi_rule_id_t, xi_rule_t, xi_rulebook_t, xrb_rules,
		   xi_rule_alloc, xi_rule_free, xi_rule_addr,
		   xi_rule_id, xi_rule_id_atom_of, xi_rule_id_is_null);

PA_FIXED_FUNCTIONS(xi_rstate_id_t, xi_rstate_t, xi_rulebook_t, xrb_states,
		   xi_rstate_alloc, xi_rstate_free, xi_rstate_addr,
		   xi_rstate_id, xi_rstate_id_atom_of, xi_rstate_id_is_null);

#endif /* LIBSLAX_XI_RULES_H */
