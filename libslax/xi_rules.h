/*
 * $Id$
 *
 * Copyright (c) 2016, Juniper Networks, Inc.
 * All rights reserved.
 * This SOFTWARE is licensed under the LICENSE provided in the
 * ../Copyright file. By downloading, installing, copying, or otherwise
 * using the SOFTWARE, you agree to be bound by the terms of that
 * LICENSE.
 *
 * Phil Shafer (phil@) June 2016
 *
 * We compile scripts into a set of rules, behaviors that are
 * triggered based on incoming elements.  These rules exist in their
 * own memory segment (pa_mmap_t) so they can be compiled once and
 * reused as needed.
 *
 * Rules are patterns to match and actions to execute when matched.
 * They are typically generated by compiling a script, but can be
 * generated directly.
 *
 * Rules are built in "states" (think YACC states) where a set of
 * rules
 */

#ifndef LIBSLAX_XI_RULES_H
#define LIBSLAX_XI_RULES_H

typedef uint8_t xi_action_type_t;

/* Values for xi_action_type_t */
#define XIA_NONE	0
#define XIA_DISCARD	1	/* Discard with all due haste */
#define XIA_SAVE	2	/* Save node (at insertion point) */
#define XIA_SAVE_ATSTR	3	/* Save node and attribute string */
#define XIA_SAVE_ATTRIB	4	/* Save node and parsed attributes */
#define XIA_EMIT	5	/* Emit as output */
#define XIA_RETURN	6	/* Force return from xi_parse() */

typedef pa_atom_t xi_rule_id_t; /* Number to represent each rule */
typedef pa_atom_t xi_state_id_t; /* Number to represent each state */

/*
 * A rule defines a behavior for an incoming token.  A token can be
 * copied, saved, or discarded.  Or a function callback can triggered.
 */
typedef struct xi_rule_s {
    xi_rule_id_t xr_next;	/* Next rule for this state */
    uint32_t xr_flags;		/* Flags for this rule */
    pa_bitmap_id_t xr_bitmap;	/* Elements affected by this rule */
    xi_action_type_t xr_action;	/* What to do when the rule matches */
    pa_atom_t xr_use_tag;	/* Different tag to emit */
    xi_state_id_t xr_new_state;	/* New state (in the rulebook) to enter */
} xi_rule_t;

/* Flags for xr_flags */
#define XRF_MATCH_ALL	(1<<0)	/* Wildcard match */

/*
 * A state represents a set of associated rules
 */
typedef struct xi_rstate_s {
    xi_rule_id_t xrbs_first_rule; /* Number of first rule (in xb_rules) */
    xi_rule_id_t xrbs_default_rule; /* Number of default rule (in xb_rules) */
    uint16_t xrbs_flags;	/* Flags for this state */
} xi_rstate_t;

/* Flags for xrbs_flags */
#define XRBSF_INUSE	(1<<0)	/* State is used/defined */

typedef struct xi_rulebook_info_s {
    xi_state_id_t xrsi_initial_state; /* First state in the rule book */
    xi_state_id_t xrsi_max_state;     /* Maximum allocated (seen) state */
} xi_rulebook_info_t;

/*
 * A rule set is an optimized set of rules
 */
typedef struct xi_rulebook_s {
    xi_workspace_t *xrb_workspace; /* Our workspace */
    xi_parse_t *xrb_script;	  /* Script we're loading/building */
    xi_rulebook_info_t *xrb_infop; /* Our information the the pa_mmap_t */
    pa_fixed_t *xrb_rules;	  /* List of rules (xi_rule_t) */
    pa_fixed_t *xrb_states;	  /* List of states (xi_rule_state_t) */
    pa_bitmap_t *xrb_bitmaps;	  /* Pool of bitmaps */
} xi_rulebook_t;

static inline xi_rstate_t *
xi_rulebook_state (xi_rulebook_t *xrbp, xi_state_id_t sid)
{
    return pa_fixed_element(xrbp->xrb_states, sid);
}

static inline xi_rule_t *
xi_rulebook_rule (xi_rulebook_t *xrbp, xi_rule_id_t rid)
{
    return pa_fixed_atom_addr(xrbp->xrb_rules, rid);
}

xi_rulebook_t *
xi_rulebook_open (const char *name);

xi_rulebook_t *
xi_rulebook_setup (xi_workspace_t *xwp, xi_parse_t *script, const char *name);

void
xi_rulebook_close (xi_rulebook_t *rules);

xi_rule_t *
xi_rulebook_find (xi_parse_t *parsep, xi_rulebook_t *xrbp, xi_rstate_t *statep,
		  pa_atom_t name_atom, const char *pref, const char *name,
		  const char *attribs);

xi_rulebook_t *
xi_rulebook_prep (xi_parse_t *input, const char *name);

void
xi_rulebook_dump (xi_rulebook_t *xrbp);

PA_FIXED_FUNCTIONS(xi_rule_t, xi_rulebook_t, xrb_rules,
		   xi_rule_alloc, xi_rule_free, xi_rule_addr);

#endif /* LIBSLAX_XI_RULES_H */
