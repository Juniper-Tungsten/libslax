/*
 * $Id$
 *
 * Copyright (c) 2016, Juniper Networks, Inc.
 * All rights reserved.
 * This SOFTWARE is licensed under the LICENSE provided in the
 * ../Copyright file. By downloading, installing, copying, or otherwise
 * using the SOFTWARE, you agree to be bound by the terms of that
 * LICENSE.
 *
 * Phil Shafer (phil@) June 2016
 *
 * We compile scripts into a set of rules, behaviors that are
 * triggered based on incoming elements.  These rules exist in their
 * own memory segment (pa_mmap_t) so they can be compiled once and
 * reused as needed.
 *
 * Rules are patterns to match and actions to execute when matched.
 * They are typically generated by compiling a script, but can be
 * generated directly.
 */

#ifndef LIBSLAX_XI_RULES_H
#define LIBSLAX_XI_RULES_H

typedef uint8_t xi_action_type_t;

/* Values for xi_action_type_t */
#define XIA_NONE	0
#define XIA_DISCARD	1	/* Discard with all due haste */
#define XIA_SAVE	2	/* Save node (at insertion point) */
#define XIA_SAVE_ATSTR	3	/* Save node and attribute string */
#define XIA_SAVE_ATTRIB	4	/* Save node and parsed attributes */
#define XIA_EMIT	5	/* Emit as output */
#define XIA_RETURN	6	/* Force return from xi_parse() */

/*
 * We use bitmasks to indicate which elements are affected by rules.
 * There is a special case where xb_len == 0 implies a match.
 */
typedef struct xi_bitmask_s {
    xi_name_id_t xb_base;	/* Base bit number */
    xi_name_id_t xb_len;	/* Length of bitmask */
    pa_atom_t xb_mask;		/* Bitmask of element ids */
} xi_bitmask_t;

/*
 * A rule defines a behavior for an incoming token.  A token can be
 * copied, saved, or discarded.  Or a function callback can triggered.
 */
typedef struct xi_rule_s {
    uint32_t xr_flags;		/* Flags for this rule */
    xi_bitmask_t xr_bitmask;	/* Elements affected by this rule */
    xi_action_type_t xr_action;	/* What to do when the rule matches */
} xi_rule_t;

/*
 * A state represents a set of associated rules
 */
typedef struct xi_ruleset_state_s {
    pa_atom_t xrss_first;	/* Number of first rule */
    uint16_t xrss_count;	/* Number of rules in this state */
    uint16_t xrss_flags;	/* Flags for this state */
} xi_ruleset_state_t;

/* Flags for xr_flags */
#define XRF_MATCH_ALL	(1<<0)	/* Wildcard match */

typedef struct xi_ruleset_info_s {
    pa_atom_t xrsi_first_rule;	/* First rule in the rule set */
} xi_ruleset_info_t;

/*
 * A rule set is an optimized set of rules
 */
typedef struct xi_ruleset_s {
    pa_mmap_t *xrs_mmap;	  /* Our memory mapped data */
    xi_ruleset_info_t *xrs_infop; /* Our information the the pa_mmap_t */
    pa_fixed_t *xrs_rules;	  /* List of rules (xi_rule_t) */
    pa_fixed_t *xrs_states;	  /* List of states (xi_ruleset_state_t) */
} xi_ruleset_t;

xi_ruleset_t *
xi_ruleset_open (const char *name);

xi_ruleset_t *
xi_ruleset_setup (pa_mmap_t *pmap, const char *name);

void
xi_ruleset_close (xi_ruleset_t *rules);

xi_rule_t *
xi_ruleset_find (xi_parse_t *parsep, pa_atom_t name_atom,
	       const char *pref, const char *name, const char *attribs);

xi_ruleset_t *
xi_rules_prep (xi_parse_t *input, const char *name);

#endif /* LIBSLAX_XI_RULES_H */
